### Table of contents

- [테스트가 어려운 코드](https://www.notion.so/01016cad18134414b884a41c40d3b364)
- 테스트 가능한 설계

## 테스트가 어려운 코드

- 하드코딩되어진 값들이 있는 코드
  - constaint 값으로 메인 코드에 하드코딩되어져 있는 부분들은 반드시 그 값만 사용해야된다는 제약사항을 떠안고 가야한다.
  - 만약 해당 값들이 경로나 IP 주소, 포트 번호와 같이 환경에 따라 변할수 있는 값들이라면 테스트를 어렵게 만든다.
- 의존 객체를 직접 생성하는 코드
  - 의존 객체를 구현체 내부안에서 직접 생성하는 경우 테스트를 어렵게 만든다.
  - 해당 코드를 테스트를 하려면 의존 객체를 생성해야하는 셋업작업을 필수적으로 할수 밖에 없다.
  - 예를 들어 의존 객체로 DB를 준비해야되며 그것에 맞춰 테이블을 만들어야되는 경우 모든 환경 구성을 무조건적으로 해야될수 밖에 없다. ⇒ 이 부분을 나중에 대역으로 풀어나갈수도 없다.
- 정적 메소드를 사용하는 코드
  - 위 의존 객체를 직접 생성하는 경우와 동일하다.
- 실행 시점에 따라 결과가 달라지는 코드
  - 아래와 같이 특정 시점을 기준으로 결과가 달라지는 코드들은 테스트하기가 어렵다.

    현재시간을 기준으로 분기로직을 타는데 현재시간은 테스트하는 시점에 따라 언제든지 변할수 있기에 테스트 결과가 달라질수 있으며 그 테스트는 믿을수 없는 테스트가 된다.

      ```tsx
      
      function test() {
        ...
        const position = Position.findOne();
        const today = LocalDate.now();
        if (position.endedAt > today) {
          ...
        } else {
          ...
        }
        ...
      }
      
      ```

- 역할이 섞여 있는 코드
  - 하나의 로직단위는 하나의 책임, 역할을 가져야하는 이유가 좋은 테스트코드를 만들기 위함에도 있다.
  - 많은 역할을 지닌 코드는 하나의 목적을 가지고 테스트하기가 어렵다. 즉 단위 테스트를 하기 어렵다.


## 테스트 가능한 설계

- 하드코딩된 상수를 생성자나 메서드 파라미터로 받기
- 의존 대상을 주입하기
  - 생성자나 세터함수를 통해서 의존성 주입이 이뤄질수 있다.  
      💡 주입 방식중 생성자 주입을 우선적으로 고려해야하는 이유  
      - [객체의 불변성 확보]<br>
       의존관계에 대한 변경이 필요한 상황은 거의 없다. ⇒ 상태 변수처럼 값의 상태가 변하지 않는다.  
       하지만 세터 함수와 같은 메서드 주입방식을 사용하게되면 불필요하게 수정 가능성을 열어두게 되어 OOP의 원칙중 OCP(Open-Closed Principal)을 위반하게 된다.  
       그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는게 좋다.  
- 시간이나 임의 값 생성 기능 분리하기
- 테스트 하고 싶은 코드를 분리하기
