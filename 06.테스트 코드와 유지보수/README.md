## 테스트 코드와 유지보수 

테스트 코드는 그 자체로 코드이기 때문에 제품(메인) 코드와 마찬가지로 동일하게 유지보수 대상이 된다.

테스트 코드는 코드를 변경했을때 기존 기능이 올바르게 동작하는지 확인하는 회귀 테스트(regression test)를 자동화는 수단으로 사용하는데 유지 보수 미약으로 인해 깨진 테스트들을 방치하게 되면 회귀 테스트를 검증하는 범위가 줄어든다.

이는 오류가 있는 코드를 놓칠 가능성이 커진다는 것을 의미한다. 그것은 다시 소프트웨어 품질이 낮아질 가능성이 커진다는 것을 의미한다.

즉 테스트 코드는 유지보수성이 좋아야 지속적으로 테스트를 작성하게 하고 결과적으로 소프트웨어의 품질이 떨어지는 것을 막을수 있다.

### 변수나 필드를 사용해서 기댓값 표현하지 않기

테스트 코드를 처음 보는 사람 입장에서 기대하는 값들이 명확하게 표현되어야 쉽게 파악이 가능하다.

필드와 변수를 사용하게 되면 테스트 코드를 파악하는데 해당 필드와 변수를 오가면서 파악해야 하기때문에 한눈에 이해하기가 어렵다.

테스트를 위해 사용되는 값들은 변수 필드에 기대어 표현하지 않고 실제 값으로 단언하는것이 가독성 측면에서 훨씬 유리하다는 점을 기억하자.

### 두개 이상 검증하지 않기

하나의 테스트 픽스처에 두개 이상을 검증하지 않는다.

두개 이상 검증되었을시 테스트가 실패됬을때 검증대상들중 무엇이 실패했는지 부차적으로 확인해야되는 문제가 있다.

한 테스트 메서드에서 서로 다른 내용을 검증하려면 각 검증 대상을 별도로 분리해서 테스트 하는 것이 집중도를 높일 뿐만 아니라 유지보수측면에서 유리하다.

### 과도하게 구현을 검증하지 않기

내부 구현을 검증하는 것은 나쁜것은 아니지만 한가지 단점을 가지고 있다.

그것은 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다는 것이다.

내부 구현은 언제든지 바뀔 여지가 있기때문에 테스트 코드는 내부 구현보다는 실행 결과에 집중해야 된다.

### 셋업을 이용해서 중복된 상황을 설정하지 않기

테스트 코드상의 본래의 의도가 중복제거로 인해 점점 모호해지면 의도파악을 제대로 할수 없다.

또한 중복을 줄이기위해 값을 가진 글로벌 변수로 공유 상태를 두는 경우가 있는데 이것은 테스트의 본질에 어긋난다. 테스트 각각의 픽스처는 서로 독립적이고 격리되어야하는데 공유상태를 둠으로써 테스트의 결합도가 높아지게 된다.

테스트를 수정했을때 다른 테스트에게 영향을 주지 않아야 한다.

### 더 이상 쓸모 없는 테스트 코드

매우 단순한 기능 테스트는 사실상 테스트 코드를 작성할 필요가 없다.

단지 테스트 커버리지를 높이기위해 존재할 뿐이다.

[테스트 커버리지]

시스템 또는 소프트웨어의 테스트를 논할 때 얼마나 테스트가 충분한가를 나타낸 것이다.

즉, 수행한 테스트가 테스트의 대상을 얼마나 커버했는지를 나타낸다

[리펙토링] 메서드 추출

리펙토링을 통해 메서드 추출기법을 사용하여 메서드 이름으로 코드의 의미를 표현한다. 아래와 같은 경우가 리펙토링이 필요한 경우이다.

- 단순 구현체만으로 의도파악이 되지 않은 경우
- 하나의 역할 자체를 가져갈수 있는 로직이 있는 경우
